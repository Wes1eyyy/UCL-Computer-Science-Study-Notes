# ğŸ“ Single Process Server: Core Ideas

![[Design 1 single process.png]]

- **Server Task**: Handle many client requests (e.g., computations) via the web.
    
- **Initial Design**:
    
    - One **monolithic**ï¼ˆå•ä½“å¼ï¼‰ server program.
        
    - Runs as a **single process**, typically with **one thread**.
        
- **Problem**:
    
    - All requests processed **sequentially**.
        
    - Only **one CPU core** is used (others idle).
        
    - **Long tasks** block all other requests.
        
    - **Result**: Very **slow** and sometimes **blocked** server.
        
- **Conclusion**:
    
    - Single-threaded servers cannot efficiently handle concurrent requests.
        
    - We must design the server to **use multiple cores** to improve performance.
        

---

# Design 2: Multiple Processes

![[Design 2 multiple processes.png]]

- **Idea**: Create a new **process** for each client connection.
    
- **Each process** has its own code, data, files, stack, and registers.
    
- **OS load balances** processes across cores automatically.
    

---

## Problems

- **High resource consumption**:  
    Each process uses separate memory and CPU â†’ wasteful.
    
- **Expensive communication**:  
    Inter-process communication (IPC) is slow and complex.
    
- **Heavy management overhead**:  
    OS spends too much time managing processes instead of running tasks.
    

---

## Summary

|Pros|Cons|
|:--|:--|
|Full CPU core utilization|Heavy resource usage|
|Simple programming model|Slow IPC and scaling issues|


---

# Design 3: Multiple Threads

![[Design 3 Multiple Threads.png]]

- **Single process**, **one thread per client**.
    
- Threads are **lightweight** and **share most resources** (code, data).
    
- Threads are **minimal scheduling units**: run independently, possibly on different cores.
    
- **Advantage**: saves resources, allows parallelism.
    
- **Problem**:
    
    - Harder to program correctly.
        
    - **Unexpected interactions** with hardware.
        
    - **Shared resource issues** (e.g., data races).
        
    - **Difficult to reason** about parallel execution.

---

### ğŸ§  Notes: Design 3 is not always best

- Not all servers must be multithreaded.
    
- Design 1 or 2 may be better if app is not CPU-intensive or time-sensitive.
    
- Tradeoff: simplicity vs correctness vs performance.  
    â†’ Pick the easiest design that meets requirements.
    
- Concurrency bugs happen when multiple processes/threads share resources.
    

---

### ğŸ§  Notes: Multithreading â‰  True Parallelism

- Multithreading support depends on language.
    
- In CPython, **GIL** allows only **one thread** to execute at a time.
    
- For real parallelism in Python, use `multiprocessing` or `concurrent.futures`.
    

---

# Concurrency Abstraction(å¹¶å‘æŠ½è±¡) 

è™½ç„¶ç°å®ä¸­ç¡¬ä»¶æ‰§è¡Œæ˜¯å¹¶å‘çš„ã€å¤æ‚çš„ï¼Œä½†æˆ‘ä»¬å¯ä»¥æŠ½è±¡æˆã€Œçº¿ç¨‹ä¹‹é—´çš„åŸå­åŠ¨ä½œè¢«**äº¤é”™æ‰§è¡Œï¼ˆinterleavingï¼‰**ã€

- Hardware **unpredictably interleaves** actions from all threads.
    
- Each thread = a **totally ordered** sequence of atomic actions.
    
- **Interleaving** = totally ordered sequence mixing actions from different threads.
    
    - Only **one action at a time** is executed.
        
    - Actions from the **same thread** keep their order.
        
- Many possible interleavings â†’ different execution results.
    

---

# Correctness of the Abstraction

- We **model** problems caused by actions from different threads.
    
- **Limitations**:
    
    - **No time modeling**.
        
    - **No hardware detail modeling** (e.g., reordering, caching).
        
- Abstraction is **good enough** for most concurrency reasoning.

---

# Building upon Concurrency Abstraction

- Concurrency abstraction helps solve concurrency problems.
    
- Solutions use **primitives of programming languages**.
    
- Programming languages provide **constructs** to:
    
    - Execute code blocks atomically (critical sections).
        
    - Restrict possible interleavings.
        
- Programming languages define **guarantees** of these constructs, independent of hardware.

---

# Interleaving Example - Minimal Notes

- Threads:
    
    - A = {A1, A2}
        
    - B = {B1}
        
- Rule:
    
    - Actions inside a thread must stay in order (A1 before A2).
        
    - Actions across threads can interleave freely.
        
- Result:
    
    - 3 interleavings: [A1, A2, B1], [A1, B1, A2], [B1, A1, A2].

---

# Interleaving Example (Variant) - Minimal Notes

- Threads:
    
    - A = {A1, A2}
        
    - B = {B1, B2}
        
- Rule:
    
    - Actions inside threads stay ordered.
        
- Result:
    
    - 6 interleavings:
        
        - If A1 first: [A1,A2,B1,B2], [A1,B1,A2,B2], [A1,B1,B2,A2]
            
        - If B1 first: [B1,A1,A2,B2], [B1,A1,B2,A2], [B1,B2,A1,A2]
            
- Insight:
    
    - Adding 1 more action â†’ doubles interleavings!

---

# Interleaving Formula - Minimal Notes

- Threads:
    
    - A has X actions
        
    - B has Y actions
        
- Total interleavings = $$(X+Y)! / (X! Ã— Y!)$$
    
- Idea:
    
    - Place all actions in sequence, keeping thread order.
        
    - "Stars and bars" method.
---

# Three Threads - Minimal Notes

- Threads:
    
    - A = {A1}
        
    - B = {B1}
        
    - C = {C1}
        
- Total actions = 3
    
- Total interleavings = 3! = 6
    
- Enumeration:
    
    - A1 first: [A1, B1, C1], [A1, C1, B1]
        
    - B1 first: [B1, A1, C1], [B1, C1, A1]
        
    - C1 first: [C1, B1, A1], [C1, A1, B1]
        

---
# Three Threads (Variant) - Minimal Notes

- Threads:
    
    - A = {A1, A2}
        
    - B = {B1}
        
    - C = {C1}
        
- Total actions = 4
    
- Rules:
    
    - Actions in the same thread must stay ordered (A1 before A2).
        
- Total interleavings = 12
    
- Enumeration:
    
    - A1 first: [A1,A2,B1,C1], [A1,A2,C1,B1], [A1,B1,A2,C1], [A1,B1,C1,A2], [A1,C1,A2,B1], [A1,C1,B1,A2]
        
    - B1 first: [B1,A1,A2,C1], [B1,A1,C1,A2], [B1,C1,A1,A2]
        
    - C1 first: [C1,B1,A1,A2], [C1,A1,B1,A2], [C1,A1,A2,B1]
        

---

## Simple program example

- **Question**: What are possible final values of `x` if:
    
    - T1: `{x=5; x=2*x}`
        
    - T2: `{x=x+2}`
        
- **Interleaving assuming atomic instructions**:
    
    1. `x=5; x=2*x; x=x+2` â†’ x=12
        
    2. `x=5; x=x+2; x=2*x` â†’ x=14
        
    3. `x=x+2; x=5; x=2*x` â†’ x=10
        
- **But are operations atomic?**
    
    - `x=2*x` = read `x` â†’ compute â†’ write result
        
    - `x=x+2` = read `x` â†’ compute â†’ write result
        
    - Can split into smaller actions (not atomic).
        
- **Thus more interleavings possible!** 4. `s=0; T1: x=s+2` â†’ x=2 5. `s=0; x=5; x=s+2; x=2*x` â†’ x=4 6. `x=5; s=5; ...; x=s+2` â†’ x=7
    
- **Key Point**:
    
    - Non-atomic instructions increase the number of possible outcomes.
        
    - Careful when assuming operations are indivisible!
        

---
# Lessons Learned:
- Combinatorial explosion: many interleavings, grows fast with more threads/actions.
- Real concurrent programs = many threads and many actions.
- Static analysis is hard â†’ need good design from the start.
- Explosion causes unpredictability and non-determinism.
- Bugs are hard to find and can stay latent for a long time.


---

### æ€»ç»“ï¼š

é¦–å…ˆï¼Œæ€»ç»“ä»Šå¤©è¯¾ä¸Šå­¦åˆ°çš„é‡è¦æ•™è®­ï¼š

1. **ç»„åˆçˆ†ç‚¸ï¼ˆCombinatorial explosionï¼‰**
    
    - å¹¶å‘ç¨‹åºä¸­ï¼Œçº¿ç¨‹çš„äº¤é”™ç»„åˆæ•°é‡éšçº¿ç¨‹æ•°å’Œæ“ä½œæ•°è¿…é€Ÿå¢é•¿ï¼ˆæ¯”å¦‚åªæœ‰ä¸¤æ¡çº¿ç¨‹æ—¶ï¼Œå°±æ˜¯äºŒé¡¹å¼ç³»æ•°ï¼‰ã€‚
        
    - çº¿ç¨‹è¶Šå¤šã€æ¯ä¸ªçº¿ç¨‹çš„æ“ä½œè¶Šå¤šï¼Œç»„åˆå°±è¶Šå¤šï¼Œå¯¼è‡´å‡ ä¹æ— æ³•ç©·ä¸¾ã€‚
        
2. **ç°å®çš„å¹¶å‘ç¨‹åºï¼ˆReal concurrent programsï¼‰**
    
    - å®é™…ç¨‹åºé€šå¸¸æœ‰**å¾ˆå¤šçº¿ç¨‹**ï¼Œæ¯ä¸ªçº¿ç¨‹åˆæœ‰**å¾ˆå¤šæ“ä½œ**ï¼Œç»„åˆè§„æ¨¡å·¨å¤§ã€‚
        
3. **é™æ€åˆ†æå¾ˆå›°éš¾ï¼ˆHard to analyze staticallyï¼‰**
    
    - ç”¨æ‰‹å·¥åˆ†ææˆ–å½¢å¼å·¥å…·å»æ¨å¯¼æ‰€æœ‰å¯èƒ½æƒ…å†µåœ¨å®é™…ä¸­ä¸å¯è¡Œã€‚
        
    - **ç»“è®ºï¼šå¿…é¡»ä¸€å¼€å§‹å°±è®¾è®¡å¥½ï¼**ï¼ˆæ¯”å¦‚ç”¨åŒæ­¥æœºåˆ¶å’Œæ­£ç¡®çš„æ¨¡å¼ï¼‰
        

4. **ä¸å¯é¢„æµ‹æ€§ä¸éç¡®å®šæ€§ï¼ˆUnpredictability & Non-determinismï¼‰**
    
    - ç¨‹åºå¯èƒ½æœ‰è®¸å¤šä¸åŒçš„æ‰§è¡Œç»“æœï¼Œè€Œä¸”éšç€è§„æ¨¡å¢å¤§ï¼Œç»“æœç§ç±»éš¾ä»¥ç©·ä¸¾ã€‚
        
    - æœ‰äº›äº¤é”™æ›´å®¹æ˜“å‘ç”Ÿï¼Œæœ‰äº›åˆ™æå°‘å‘ç”Ÿï¼š
        
        - å¯¼è‡´**å¹¶å‘bugéš¾ä»¥æµ‹è¯•å‘ç°**ã€‚
            
        - å°‘è§çš„äº¤é”™å¯èƒ½æ½œè—ç€**æ½œåœ¨bugï¼ˆlatent bugsï¼‰**ï¼Œåªæœ‰åœ¨æå°‘çš„æƒ…å†µä¸‹æ‰è§¦å‘ã€‚
            

---
