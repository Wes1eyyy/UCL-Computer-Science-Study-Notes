# Concurrency and Visibility Issues ‚Äì Notes

- **OS runs threads concurrently**, possibly on different processors.
    
- **Interference**: Threads may update shared data simultaneously, causing inconsistent state.
    
- **Solution**: Use **synchronization** (e.g., locking) to enforce **mutual exclusion** on **critical sections**.
    

---

# Example Problem

![[example intention.png]]

- A thread (`Reader`) spins on `ready`, then prints `number`.
    
- **Expectation**: Print 42.
    
- **Reality**: May print 0 or loop forever.
    
    - No guarantee that writes (`number=42`, `ready=true`) are seen by other threads immediately.
        
    - CPU reordering and cache incoherence cause **visibility problems**.
        

---

# Key Concepts

- **Interference** = too much interaction ‚Üí data corruption.
    
- **Visibility problem** = too little interaction ‚Üí stale or missing updates.
    
- **Concurrency abstraction**:
    
    - Defines per-thread action order but abstracts away real hardware behavior.
        
    - Useful for detecting **interference**, but not enough for **visibility** issues.
        

---

# Lessons

- **Synchronization** is needed whenever **shared data** is accessed (both read and write).
    
- Manual analysis of concurrent programs is hard ‚Üí **design carefully**.
    
- **Combinatorial explosion**: many interleavings ‚Üí unpredictability and non-determinism.
    
- **Concurrency bugs** can be **rare** and **hard to detect**.

---

### Why Synchronization?

- Threads must sync working memory at entry/exit of synchronized blocks.
    
- Unlock by Thread A ‚Üí visible after Lock by Thread B.
    

---

### Subtle Visibility Problem

- Threads can see **partially constructed objects**.
    
- Example: One thread creates, another reads before construction is complete ‚Üí `AssertionError`.

### Avoiding Visibility Problems (ÈÅøÂÖçÂèØËßÅÊÄßÈóÆÈ¢ò)

ÂØπ‰∫é‰ªª‰ΩïÂÖ±‰∫´ÂØπË±°ÔºåÊàë‰ª¨Êúâ‰∏§‰∏™**È´òÂ±ÇÊ¨°ÁõÆÊ†á**Ôºö

- **G1**: ‰øùËØÅÊ≤°ÊúâÁ∫øÁ®ãÁúãÂà∞**ÈÉ®ÂàÜÊûÑÈÄ†**Ôºàpartially constructedÔºâÁöÑÂØπË±°„ÄÇ
    
- **G2**: ‰øùËØÅÊâÄÊúâÁ∫øÁ®ãËÉΩ**ÁúãÂà∞ÂØπË±°Áä∂ÊÄÅÁöÑÂèòÂåñ**„ÄÇ


Ë¶ÅÂÆûÁé∞Ëøô‰∫õÁõÆÊ†áÔºåÂèñÂÜ≥‰∫éÂØπË±°ÁöÑ**Á±ªÂûã**„ÄÇ

#### 1. Local to threadÔºà‰ªÖÂú®Á∫øÁ®ãÂÜÖÈÉ®‰ΩøÁî®ÁöÑÂØπË±°Ôºâ

- ËøôÁßçÂØπË±°**Ê†πÊú¨‰∏çÂÖ±‰∫´**„ÄÇ
    
- ‚úÖ G1 Ëá™Âä®Êª°Ë∂≥„ÄÇ
    
- ‚úÖ G2 Ëá™Âä®Êª°Ë∂≥„ÄÇ
    
- Âõ†‰∏∫Ê†πÊú¨Ê≤°ÊúâÂÖ∂‰ªñÁ∫øÁ®ãËÉΩÁúãÂà∞ÂÆÉ„ÄÇ
    

#### 2. ImmutableÔºà‰∏çÂèØÂèòÂØπË±°Ôºâ

- ÂØπË±°‰∏ÄÊó¶ÂàõÂª∫ÂêéÔºåÂ∞±‰∏ç‰ºöÊîπÂèòÔºàÂ¶Ç `String`„ÄÅÂ∞ÅË£ÖÂ•ΩÁöÑÂØπË±°Ôºâ„ÄÇ
    
- ‚úÖ G1 Êª°Ë∂≥„ÄÇ
    
- ‚úÖ G2 Êª°Ë∂≥„ÄÇ
    
- Âõ†‰∏∫Ê≤°Êúâ‰øÆÊîπÔºåÊâÄ‰ª•ÂèØËßÅÊÄßÈóÆÈ¢ò‰∏çÂ≠òÂú®„ÄÇ
    

#### 3. Effectively ImmutableÔºàÂÆûÈôÖ‰∏çÂèØÂèòÂØπË±°Ôºâ

- ÂØπË±°ÁêÜËÆ∫‰∏ä‰∏çÂèØÂèòÔºå‰ΩÜÂú®ÂàõÂª∫ÂêéÂøÖÈ°ª**ÂÆâÂÖ®ÂèëÂ∏ÉÔºàsafely publishedÔºâ**„ÄÇ
    
- ‚û° G1ÔºöÈúÄË¶Å**ÂÆâÂÖ®ÂèëÂ∏É**‰øùËØÅ„ÄÇ
    
- ‚úÖ G2Ôºö‰∏ÄÊó¶ÂÆâÂÖ®ÂèëÂ∏ÉÊàêÂäüÔºåÁä∂ÊÄÅÂèòÂåñÊòØÂèØËßÅÁöÑ„ÄÇ
    
- ÂÖ∏Âûã‰æãÂ≠êÔºöÂàõÂª∫Âêé‰∏çÂÜç‰øÆÊîπÁöÑÂØπË±°Ôºå‰ΩÜÈúÄË¶Å‰øùËØÅÊûÑÈÄ†ÂÆåÊàêÂêéÂÜçÂÖ±‰∫´Âá∫Âéª„ÄÇ
    

#### 4. MutableÔºàÂèØÂèòÂØπË±°Ôºâ

- ÂØπË±°ÁöÑÁä∂ÊÄÅ**‰ºöÂèòÂåñ**ÔºåËÄå‰∏î**Â§ö‰∏™Á∫øÁ®ãÂèØËÉΩÂêåÊó∂ËØªÂÜô**„ÄÇ
    
- ‚û° G1ÔºöÂøÖÈ°ªÈÄöËøá**ÂÆâÂÖ®ÂèëÂ∏É**‰øùËØÅÂàùÂßãÁä∂ÊÄÅÂÆåÊï¥ÂèØËßÅ„ÄÇ
    
- ‚û° G2ÔºöÂøÖÈ°ª**Á∫øÁ®ãÂÆâÂÖ®**ÔºåÊàñËÄÖ**ÈÄöËøáÈîÅ‰øùÊä§**ÔºåÂê¶ÂàôÁä∂ÊÄÅÂèòÂåñÊó†Ê≥ïÊ≠£Á°ÆÂêåÊ≠•Âà∞ÂÖ∂‰ªñÁ∫øÁ®ã„ÄÇ
    

---

### Â∞èÁªìÔºàSummaryÔºâ

|Object Type|Goal G1|Goal G2|
|---|---|---|
|Local to thread|‚úÖ|‚úÖ|
|Immutable|‚úÖ|‚úÖ|
|Effectively immutable|Must be safely published|‚úÖ|
|Mutable|Must be safely published|Must be thread-safe or lock-guarded|


---

### Publication

- **Publication** = making an object available outside current context.
    
- Danger: Publishing during construction ‚Üí exposure of incomplete objects.
    

---

### Safe Publication

- Ways to safely publish:
    
    - Final fields
        
    - Proper synchronization (locks)
        
    - Volatile fieldsÔºàÊòìÂ§±Â≠óÊÆµÔºâ or AtomicReference
	    - `volatile` ÁöÑÊÑèÊÄùÊòØÔºö
			- ‰ªª‰Ωï**ÂÜôÂÖ•**ÈÉΩ‰ºöÁ´ãÂàª**Âà∑Êñ∞Âà∞‰∏ªÂÜÖÂ≠ò**Ôºõ
			- ‰ªª‰Ωï**ËØªÂèñ**ÈÉΩ‰ºöÁ´ãÂàª**‰ªé‰∏ªÂÜÖÂ≠ò**ÊãâÂèñÊúÄÊñ∞ÁöÑÂÄº„ÄÇ
        
    - Static initializer
        

---

# üß† Safe Publication in Java Example
## Problem: Unsafe Publication

- Publishing an object (e.g., `public Holder holder;`) without synchronization can expose a **partially constructed** object to other threads.
    
- Other threads may observe an inconsistent or incomplete state.
    

---

## Solutions for Safe Publication

### 1. Make the Object **Immutable**

```java
public class Holder {
    private final int n;
    public Holder(int n) { this.n = n; }
}
```

- Use `final` fields to guarantee **complete construction**.
    
- **Immutable objects** are safely published once construction finishes.
    
- ‚úÖ No need for synchronization after publication.
    

---

### 2. Static Initialization

```java
public static Holder holder = new Holder(42);
```

- Static fields initialized at class loading are **thread-safe**.
    
- ‚úÖ Guarantees full construction before any access.
    

---

### 3. Using `volatile`

```java
public volatile Holder holder;
```

- Ensures that **writes** to `holder` are immediately visible to all threads.
    
- Reads always return the **latest** written value.
    
- ‚úÖ Lightweight synchronization.
    
- ‚ö†Ô∏è Only ensures visibility of the reference, not the inner object unless immutable.
    

---

### 4. Using `synchronized`

```java
public synchronized Holder getHolder() {
    return holder;
}
```

- Full safe publication and **thread-safe access**.
    
- ‚úÖ Suitable for mutable or complex shared objects.
    
- ‚ö†Ô∏è Introduces **performance overhead**.
    

---

## Quick Comparison Table

|Approach|Guarantees|Notes|
|---|---|---|
|Make Immutable (`final`)|Full safe construction and visibility|Best if possible|
|Static Initialization|Full safe publication|Only for static fields|
|volatile|Reference visibility (weak sync)|Object must be immutable|
|synchronized|Full safe publication + access|Strong but heavier|

---

## Key Takeaways

> **Safe publication** ensures an object is fully constructed and visible to all threads before use.  
> Using **`final` fields** in immutable objects is the simplest and safest strategy.

---

## ‚úèÔ∏è Concurrent Programming: Producer-Consumer Pattern

### Blocking Buffer

- A **blocking buffer** is a shared queue for producer and consumer threads.
    
- **Producer** must wait if the buffer is full.
    
- **Consumer** must wait if the buffer is empty.
    

### Buffer Operations

- `put(x)`: Add an item `x` to the buffer.
    
- `take()`: Remove and return an item from the buffer.
    
- Both must be **synchronized** to ensure thread safety.
    

### Conditional Synchronization

- Threads must:
    
    1. Acquire the lock.
        
    2. Check the condition (buffer full/empty).
        
    3. If the condition is not met, call `wait()` to release the lock and sleep.
        
    4. Upon waking up, reacquire the lock and recheck the condition.
        
    5. When the condition is met, perform the action.
        
    6. Call `notifyAll()` to wake up other threads.
        
    7. Release the lock.
        
- **Important**: Always use `while` loops (not `if`) to handle **spurious wakeups**.
    

### Pseudocode Example

```java
public synchronized void put(Object x) {
    while (buffer is full) {
        wait();
    }
    add x to buffer;
    notifyAll();
}

public synchronized Object take() {
    while (buffer is empty) {
        wait();
    }
    Object x = remove from buffer;
    notifyAll();
    return x;
}
```

### Key Points

- `wait()` causes a thread to sleep and release the lock.
    
- `notifyAll()` wakes up all waiting threads.
    
- Condition must be re-checked after waking up.
    

---