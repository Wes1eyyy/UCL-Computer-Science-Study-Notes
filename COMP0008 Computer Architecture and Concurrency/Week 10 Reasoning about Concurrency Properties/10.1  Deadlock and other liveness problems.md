
## Synchronization ≠ Correctness

- **Synchronization** restricts the set of possible interleavings, avoiding interference and visibility issues.
    
- **Locks** ensure mutual exclusion and define atomic actions.
    
- **Safe publication** guarantees visibility across threads.
    
- Synchronization improves **safety** (nothing bad happens).
    

**But:**

- **Correctness** includes both:
    
    - **Safety** (no errors)
        
    - **Liveness** (something good eventually happens)
        
- Synchronization **alone** does **not** ensure **liveness**.
    
- Worse: **Safety often conflicts with liveness**.  
    (e.g., improper locking can block all progress.)
    

---

### Deadlock - Definition

![[Traffic gridlock example.png]]

- **Deadlock** occurs when all threads are permanently blocked.
    
- **Typical cause**: cyclic dependencies in resource acquisition (e.g., thread A waits for thread B’s resource, and thread B waits for thread A’s resource).
    
- **Real-world analogy**: traffic gridlock – no vehicle can move because each one is waiting for another.
    
- **Key symptoms**:
    
    - No thread can proceed.
        
    - System is stuck indefinitely.
        

---

# Deadlock Avoidance Summary

### 1. Enforce Lock Ordering

- Always acquire locks in a consistent global order (e.g., by account ID).
    
- In `transferMoneyOrdered`, lock the lower ID first, then the higher ID.
    
- Ensures no cyclic waiting → no deadlock.
    

### 2. Open Calls

- Avoid calling external methods while holding a lock.
    
- Release locks before making external calls to prevent unexpected blocking.
    
- **Caveat**: May lose atomicity, so use carefully.
    

### Key Principle:

> **Consistent lock ordering + Open calls = Deadlock-free design**


---

# Concurrency Liveness Issues – Quick Notes

## 1. Livelock

- A thread is **not blocked** but **makes no useful progress**.
    
- Example:
    
    - _Polite people in a hallway_ (keep avoiding each other).
        
    - _WiFi link_: clients collide and endlessly retry.
        
- **Solution**: Add **randomness** (random backoff) in retry logic.
    

## 2. Incorrect Conditional Synchronization

- **Missed signals** cause threads to wait forever, even if the condition is satisfied.
    
- Common mistakes:
    
    - Not checking the condition **before** waiting.
        
    - Not waking up threads after a condition change.

Condition queues offer methods to 
- wait() allows threads to enter a condition queue
- notify() wakes up one thread in the wait set
- notifyAll() wakes up all threads in the wait set


## 3. Correct Wait Loop Pattern

- Always use **while**, not **if**, when waiting on a condition:
    
    ```java
    synchronized (lock) {
        while (!condition) {
            lock.wait();
        }
        // safe to proceed
    }
    ```
    
- Reason: Condition might not be true when a thread wakes up.
    

---

### Conditional Synchronization: Key Points

- **Always re-check conditions after `wait()`** using a `while` loop, not an `if`.
    
- **Use `notifyAll()`** to wake up all waiting threads after a state change.
    
- Correct handling ensures:
    
    - Threads only proceed when the condition is truly satisfied.
        
    - No assertion errors or illegal states occur even with many concurrent operations.
        

✅ Following these rules ensures safe and correct concurrent behavior.

---
