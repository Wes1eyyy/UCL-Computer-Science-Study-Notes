åŸºäºä½ ä¸Šä¼ çš„æ‰€æœ‰å†…å®¹ï¼Œä¸‹é¢æ˜¯ä¸€ä»½**å®Œæ•´çš„ MIPS ç³»ç»Ÿè°ƒç”¨ã€å¼‚å¸¸å¤„ç†ã€å†…å­˜ç»„ç»‡å’Œåå¤„ç†å™¨ä½¿ç”¨**çš„ç¬”è®°æ•´ç†ï¼Œé€‚åˆ Obsidian ä½¿ç”¨ âœ…ï¼š

---

## ğŸ§  MIPS Memory Map & Registers

### ğŸ“Œ Memory Segments:

|Segment|Address Range|Notes|
|---|---|---|
|**Stack**|`0x7ffffffc â†“`|Local vars, grows down, `$sp`|
|**Heap (malloc)`**|`0x10010000 â†‘`|Dynamic allocation|
|**Static Data**|`0x10000000`|Global vars, `$gp` points here|
|**Text**|`0x00400000`|Program code|
|**Reserved**|`0x00000000`|OS reserved|
|**Kernel space**|`> 0x80000000`|Only kernel can access|

---

## âš™ï¸ MIPS2000 Coprocessors

### ğŸ‘¥ Coprocessor 0:

- Handles **exceptions / traps**
    
- Important Registers:
    
    - `Status`
        
    - `Cause` (stores **exception code**)
        
    - `EPC` (stores **PC before exception**)
        
    - `BadVAddr`
        

### ğŸ§® Coprocessor 1 (FPU):

- Handles **floating-point operations**
    
- Has its own 32 registers (`$f0` â€“ `$f31`)
    

---

## ğŸ§¨ MIPS Exceptions (Trap Handling)

### ğŸ“ On Exception:

1. `Cause` register â† exception code
    
2. `EPC` register â† current PC
    
3. `PC â† 0x80000080` (handler address)
    
4. May use `$k0`, `$k1` (kernel scratch regs)
    

---

### ğŸ”¢ Exception Codes (selected):

|Code|Name|Description|
|---|---|---|
|0|`Int`|Hardware interrupt|
|4|`AdEL`|Load / fetch addr error|
|5|`AdES`|Store addr error|
|8|`Sys`|**Syscall Exception**|
|10|`RI`|Reserved instruction|
|12|`Ov`|Arithmetic overflow|

---

## ğŸ–¥ï¸ `syscall` Instruction

### ğŸ”§ Purpose:

- Interface for **OS services** (I/O, exit, memory)
    

### ğŸ§¾ Format:

```asm
addi $v0, $0, <code>   # syscall ID
# args â†’ $a0-$a3 or $f12
syscall
```

---

### ğŸ“œ Common Syscall Codes:

|Code|Service|Input Regs|Output|
|---|---|---|---|
|1|print_int|`$a0 = int`|â€“|
|4|print_string|`$a0 = string addr`|â€“|
|5|read_int|â€“|`$v0 = int`|
|8|read_string|`$a0 = buf`, `$a1 = len`|â€“|
|10|exit|â€“|â€“|
![[Common Syscall Codes.png]]
---

## ğŸ’¬ Syscall Example: Add Two Numbers

```asm
.data
str1: .asciiz "Enter first: "      # è¾“å…¥ç¬¬ä¸€ä¸ªæ•°å­—çš„æç¤ºå­—ç¬¦ä¸² 
str2: .asciiz "Enter second: "     # è¾“å…¥ç¬¬äºŒä¸ªæ•°å­—çš„æç¤ºå­—ç¬¦ä¸² 
str3: .asciiz "Sum is: "           # è¾“å‡ºç»“æœæç¤ºå­—ç¬¦ä¸² 

.text
.globl main
main:
  li $v0, 4                        # ç³»ç»Ÿè°ƒç”¨ä»£ç  4ï¼šæ‰“å°å­—ç¬¦ä¸² 
  la $a0, str1                     # åŠ è½½ str1 çš„åœ°å€åˆ° $a0 
  syscall                          # è°ƒç”¨ç³»ç»ŸæœåŠ¡ï¼šæ‰“å° "Enter first: " 

  li $v0, 5                        # ç³»ç»Ÿè°ƒç”¨ä»£ç  5ï¼šè¯»å–æ•´æ•° 
  syscall                          # è°ƒç”¨ç³»ç»ŸæœåŠ¡ï¼šè¯»å–è¾“å…¥çš„æ•´æ•° 
  move $t1, $v0                    # æŠŠè¯»å–çš„æ•´æ•°ä¿å­˜åˆ° $t1 

  li $v0, 4                        # æ‰“å°ç¬¬äºŒä¸ªæç¤ºè¯­å¥ 
  la $a0, str2                     # åŠ è½½ str2 åœ°å€åˆ° $a0 
  syscall                          # æ‰“å° "Enter second: " 

  li $v0, 5                        # è¯»å–ç¬¬äºŒä¸ªæ•´æ•°
  syscall                          # æ‰§è¡Œç³»ç»Ÿè°ƒç”¨è¯»å–è¾“å…¥
  add $t1, $t1, $v0                # æŠŠä¸¤ä¸ªè¾“å…¥ç›¸åŠ ï¼Œç»“æœå­˜å› $t1 

  li $v0, 4                        # æ‰“å°ç»“æœæç¤º
  la $a0, str3                     # åŠ è½½ str3 åœ°å€
  syscall                          # æ‰“å° "Sum is: "

  li $v0, 1                        # ç³»ç»Ÿè°ƒç”¨ä»£ç  1ï¼šæ‰“å°æ•´æ•°
  move $a0, $t1                    # æŠŠç»“æœæ”¾è¿› $a0 å‡†å¤‡æ‰“å°
  syscall                          # æ‰“å°ä¸¤ä¸ªæ•°çš„å’Œ 

  li $v0, 10                       # ç³»ç»Ÿè°ƒç”¨ä»£ç  10ï¼šé€€å‡ºç¨‹åº
  syscall                          # ç¨‹åºç»“æŸ

```

---
