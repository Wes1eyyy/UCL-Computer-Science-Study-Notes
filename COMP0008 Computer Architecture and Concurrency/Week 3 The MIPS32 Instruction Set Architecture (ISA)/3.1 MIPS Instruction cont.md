## ðŸ”¢ Signed vs Unsigned in MIPS

---

### ðŸ§  1. What is Unsigned Arithmetic?

- **Unsigned**: treats all values as non-negative integers  
    â†’ Range: `0` to `4,294,967,295` (`2Â³Â²âˆ’1`)
    
- **Signed**: uses 2's complement  
    â†’ Range: `âˆ’2,147,483,648` to `+2,147,483,647`
    

---

### âœ… 2. Unsigned Operations in MIPS

MIPS provides **unsigned versions** of arithmetic and comparison:

|Instruction|Description|
|---|---|
|`addu`|Unsigned add (no overflow trap)|
|`subu`|Unsigned subtract|
|`sltu`|Unsigned less-than|
|`andi`, `ori`|Bitwise ops (always unsigned logic)|

- Uses **zero extension** for immediates (not sign extension)
    

---

### ðŸš¨ 3. Why is `addiu` called "unsigned"?

- Historical reason: `addiu` = "add immediate, **no overflow trap**"
    
- **Still uses sign extension** for immediate  
    â†’ `0xFFFF` becomes `-1`
    

ðŸ“Œ Key idea:

> `addiu` behaves like `addi`, **but never raises overflow exception**.  
> **It is NOT truly unsigned arithmetic.**

---

### âœ… Real Unsigned Arithmetic?

Use:

```asm
addu $t0, $t1, $t2     # unsigned addition
sltu $t0, $t1, $t2     # set if $t1 < $t2 (unsigned)
```

---

## ðŸ“Š Summary Comparison

|Feature|`addi` / `addiu`|`addu` / `subu`|
|---|---|---|
|Immediate sign-extended|âœ… Yes|âŒ No (no immediate)|
|Overflow trap|`addi` traps, `addiu` doesn't|âŒ Never traps|
|Truly unsigned logic|âŒ No|âœ… Yes|


---

## ðŸ” I-Type Branch Instructions (MIPS)

Used to **control loops and conditionals**.

### ðŸ§  Format:

```text
I-type: op | rs | rt | imm (16-bit offset)
```

---

### ðŸ”¹ Common Branches:

|Instruction|Meaning|Behavior|
|---|---|---|
|`beq $rs, $rt, offset`|Branch if equal|If `$rs == $rt`, PC = PC + 4 + (offset Ã— 4)|
|`bne $rs, $rt, offset`|Branch if not equal|If `$rs â‰  $rt`, PC = PC + 4 + (offset Ã— 4)|

> Example:

```asm
bne $9, $0, -3
```

â†’ offset = `0xFFFD` = `-3`  
â†’ jump **backwards** by 3 instructions if `$9 â‰  0`

---

## ðŸ” Special Branches (compare with 0)

Used to simplify conditions like `x > 0`, `x <= 0`, etc.

|Instruction|Condition|
|---|---|
|`bgez $rs`|`$rs â‰¥ 0`|
|`bgtz $rs`|`$rs > 0`|
|`blez $rs`|`$rs â‰¤ 0`|
|`bltz $rs`|`$rs < 0`|

> ðŸ”Ž Trivia:  
> Both `bgez` and `bltz` use **opcode = 1**  
> â†’ They are differentiated using **`rt` field**

---

## ðŸ§  Translating `if (x â‰¤ y)`:

There is **no native instruction for `x â‰¤ y`**, but we can emulate it:

```asm
slt $at, $y, $x   # $at = 1 if y < x
beq $at, $zero, label  # if !(y < x), then x â‰¤ y
```

Or use **pseudo-instructions** (assembler expands it):

- `bgt`, `ble`, `blt` â† _not native MIPS instructions!_
    
